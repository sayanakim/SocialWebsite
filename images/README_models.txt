images

Это модель, которую мы собираемся использовать для хранения 
изображений с различных ресурсов. Давайте взглянем на поля этой 
модели:

user: Объект User, который создает закладку(bookmarked) это 
изображение. Это поле ForeignKey, поскольку оно указывает 
отношение «один-ко-многим»: пользователь может разнести 
несколько постов с одними и теми же изображениями, но каждое 
изображение постится одним пользователем.

title: Заголовок изображения
slug: Адрес, содержащий в себе только буквы, цифры, знаки 
подчеркивания или дефисы, которые будут использоваться для 
создания человекопонятных URL-ов
url: Оригинальный URL-адрес изображения
image: Файл изображения
description: Описание изображения(опционально)
created: Значение datetime, указывает, когда объект был создан в 
базе данных. Поскольку мы используем auto_now_add, datetime 
автоматически устанавливается при создании объекта. Мы используем 
db_index=True, чтобы Джанго создавал индекс в базе данных для 
этого поля.
index базы данных повысит скорость запросов. Рекомендуется 
установить setting db_index=True для полей, которые часто 
запрашиваются с помощью filter(), exclude(), или order_by(). 
Наличие ForeignKey поля или поля с unique=True подразумевает 
создание индекса. Можно также использовать Meta.index_together 
для создания индексов для нескольких полей.

Мы собираемся переопределить метод save() модели Image для 
автоматического создания служебного поля на основе значения поля 
title. Импортируйте функцию slugify() и добавьте в модель Image 
метод save()

def save

В этом коде мы используем функцию slufigy(), предоставленную с 
помощью Джанго, чтобы автоматически генерировать slug изображения 
для данного заголовка, если он не был предоставлен. Затем мы 
сохраняем объект. Мы будем автоматически генерировать slug для 
изображений, чтобы пользователи не вводили его для каждого изображения.

При определении ManyToManyField, Джанго создает промежуточную таблицу соединения с использованием primary keys обеих моделей. ManyToManyField может быть определена в любой из двух связанных моделей.

Как и в случае с полями ForeignKey, атрибут related_name of 
ManyToManyField позволяет нам присваивать имя отношениям от 
связанного объекта. Поля ManyToManyField предоставляют связь 
«многие ко многим», который позволяет нам извлекать связанные 
объекты, такие как image.users_like.all() или из объекта 
пользователя, например user.images_liked.all().

def clean_url

В этом коде мы определим метод clean_url(), чтобы очистить поле 
url. Код работает следующим образом:

Мы получим значение поля url, обратившись к cleaned_data 
словарю экземпляра формы. Мы разделяем URL-адрес, чтобы получить 
расширение файла и проверить, существует ли у него одно из 
допустимых расширений. Если он не имеет таковых, мы вызываем 
ValidationError, и экземпляр формы не будет проверен. Мы 
выполняем очень простую проверку. Можно использовать более 
сложные методы, чтобы проверить, является ли данный URL 
допустимым файлом изображения или нет.
Помимо проверки заданного URL-адреса, нам также потребуется 
загрузить файл изображения и сохранить его. Например, можно 
использовать представление, обрабатывающее форму для загрузки 
файла изображения. Вместо этого мы собираемся использовать более 
общий подход, переопределяя метод save() формы модели для 
выполнения этой задачи при каждом сохранении формы.